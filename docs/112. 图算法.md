## 图算法

图的邻接表表示：

```cpp
std::map<int, std::list<int>>  graph;
```

对图问题，首先要有一个`api adj`:

```cpp
// 输入节点s,返回节点s的相邻节点
std::list<int> adj(int s) {
  return graph[s];
}
```

对于加权图，需要知道其权值，可以抽象出`weight`方法：

```cpp
// 返回节点from到节点to的权重
int weight(int from, int to);
```

### 从二叉树层序遍历推到`Dijkstra`算法

二叉树层序遍历框架：

```cpp
void levelTravel(TreeNode *root) {
  if(root == nullptr) {
    return ;
  }

  std::list<TreeNode *> que;
  que.push_back(root);

  int level = 1;

  // 从上到下遍历二叉树节点
  while(!que.size()){
    int sz = que.size(); // 当前层的节点数，当前层的节点已全部写入que

    // 遍历每层的节点
    for(int i=0;i<sz;i++){
      TreeNode *t = que.front();
      que.pop_front();

      if(t->left != nullptr) {
        que.push_back(t->left);
      }

      if(t->right != nullptr) {
        que.push_back(t->right);
      }
    }
    level++;
  }
}

```

从二叉树层序遍历可以得到多叉树层序遍历：

```cpp
void levelTraveser(mTreeNode *root){
  if(nullptr == root) {
    return ;
  }
  std::list<mTreeNode *> que;
  que.push_back(root);
  int level = 1;

  // 从上到下
  while(que.size()) {
    int sz = que.size();
    for(int i = 0; i < sz; i++) {
      mTreeNode *t = que.front();
      que.pop_front();

      for(auto iter : t->children){
        que.push_back(iter);
      }
    }

    level++;
  }

}

```

多叉树可以推导出`BFS`框架：

```cpp
void bfs(node s) {
  std::list<node> que;
  std::set<node> visited; // 防止走回头路

  que.push_back(s); // 加入起点
  visited.insert(s);

  while(que.size()) {
    int sz = que.size();

    for(int i =0;i<sz;i++) {
      Node t = que.front();
      que.pop_front();

      // t 的相邻节点如队列
      for(auto iter : adj(t)){
        if(visited.count(iter) == 0) {
          que.push_back(iter);
          visited.insert(iter);
        }
      }
    }
    step++;
  }

}
```

`Dijkstra`算法框架：

```cpp
#include <climits>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <vector>

class graph {
public:
  // 输入一幅图graph,和一个起点start,计算start到其他节点的距离
  std::vector<int> dijkstra(int start) {
    // 途中节点个数
    int v = graph.size();
    // 记录最短路径的权重数组
    std::vector<int> dis = std::vector<int>(v, INT_MAX);

    // base case
    dis[0] = 0;

    // 按照distFromStart排序的小根堆
    std::priority_queue<state, std::vector<state>, greator> heap;

    // 从起点开始进行BFS
    heap.push(state(start, 0));
    while (heap.size()) {
      state curstate = heap.top();
      heap.pop();
      int currid            = curstate.id;
      int currdistfromstart = curstate.distFromStart;

      if (currdistfromstart > dis[currid]) {
        // 已经有一条最短路径到达当前节点
        continue;
      }

      for (auto iter : adj(currid)) {
        int distCurr = dis[currid] + weight(iter, currid);
        if (dis[iter] > distCurr) {
          // 更新结果
          dis[iter] = distCurr;
          // 将节点和距离加入到堆中
          heap.push(state(iter, distCurr));
        }
      }
    }

    return dis;
  }

private:
  std::list<int> adj(int i) {
    return graph[i];
  }

  // 获取权重
  int weight(int from, int to);

  struct state {
    state(int id, int dis) : id(id), distFromStart(dis) {
    }

    int id;             // 图的节点
    int distFromStart;  // 从start节点到当前节点的距离
  };

  struct greator {
    bool operator()(const state &s1, const state &s2) {
      return s1.distFromStart > s2.distFromStart;
    }
  };

  // 邻接表表示的图，key为图的当前节点，value为<临边节点，权重>
  std::map<int, std::list<int>> graph;
};

```

时间复杂度：`O(ElogE)`

习题：

1. 网络延迟时间(743)

```
有 n 个网络节点，标记为 1 到 n。

给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。
```

分析：
`dijkstra`距离中的最大值

```cpp
#include <climits>
#include <list>
#include <map>
#include <queue>
#include <vector>

// @lc code=start
class Solution {
public:
  int networkDelayTime(std::vector<std::vector<int>> &times, int n, int k) {
    createGraph(times);
    std::vector<int> res = dijkstra(k, n);

    int t = 0;
    for (int i = 1; i <= n; i++) {
      if (INT_MAX == res[i]) {
        // 存在节点不可达
        return -1;
      } else {
        t = (t > res[i] ? t : res[i]);
      }
    }

    return t;
  }

private:
  std::vector<int> dijkstra(int start, int n) {
    std::vector<int> res = std::vector<int>(n + 1, INT_MAX);
    std::priority_queue<state, std::vector<state>, greator> heap;  // 小根堆
    res[start] = 0;
    // base case
    heap.push(state(start, 0));

    while (heap.size()) {
      state curstate = heap.top();
      heap.pop();

      int currid   = curstate.id;
      int currdist = curstate.distfromstart;

      if (res[currid] < currdist) {
        continue;
      }

      for (auto item : adj(currid)) {
        int dist = currdist + item.second;

        if (dist < res[item.first]) {
          res[item.first] = dist;
          heap.push(state(item.first, dist));
        }
      }
    }

    return res;
  }

  void createGraph(std::vector<std::vector<int>> &times) {
    for (auto item : times) {
      graph[item[0]].push_back(std::make_pair(item[1], item[2]));
    }
  }

  std::list<std::pair<int, int>> adj(int v) {
    return graph[v];
  }

  struct state {
    state(int id, int dis) : id(id), distfromstart(dis) {
    }

    int id;
    int distfromstart;
  };

  struct greator {
    bool operator()(const state &s1, const state &s2) {
      return s1.distfromstart > s2.distfromstart;
    }
  };

  std::map<int, std::list<std::pair<int, int>>> graph;
};
// @lc code=end

```

2. 最小体力消耗路径

```
你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。

一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。

请你返回从左上角走到右下角的最小 体力消耗值 。
```

分析：
对二维矩阵运动问题，如果方向一定，可以选择向下，或向右，直接采用`dp`即可；
但对可以上下左右移动，只能采用`dijsktra`算法。

```cpp

#include <climits>
#include <cmath>
#include <list>
#include <queue>
#include <vector>

// @lc code=start
class Solution {
public:
  int minimumEffortPath(std::vector<std::vector<int>> &heights) {
    int row = heights.size();
    if (0 == row) {
      return 0;
    }
    int col = heights[0].size();

    std::vector<std::vector<int>> effortTo =
        std::vector<std::vector<int>>(row, std::vector<int>(col, INT_MAX));

    std::priority_queue<state, std::vector<state>, greator> hp; // 小根堆
    hp.push(state(0, 0, 0));
    effortTo[0][0] = 0;

    while (hp.size()) {
      state cursate = hp.top();
      hp.pop();

      if (cursate.x == row - 1 && cursate.y == col - 1) {
        // 到达末尾
        return cursate.distfromstart;
      }

      if (effortTo[cursate.x][cursate.y] < cursate.distfromstart) {
        continue;
      }

      for (auto item : adj(cursate.x, cursate.y, row, col)) {
        // 计算从curstate.x,curstate.y 到 item.first, item.second的消耗
        int dist = std::max(effortTo[cursate.x][cursate.y],
                            abs(heights[item.first][item.second] -
                                heights[cursate.x][cursate.y]));

        if (dist < effortTo[item.first][item.second]) {
          effortTo[item.first][item.second] = dist;
          hp.push(state(item.first, item.second, dist));
        }
      }
    }

    return -1;
  }

private:
  std::list<std::pair<int, int>> adj(int x, int y, int row, int col) {
    std::list<std::pair<int, int>> neightors;
    for (auto item : dir) {
      int dx = x + item[0];
      int dy = y + item[1];

      if (isInArea(dx, dy, row, col)) {
        neightors.push_back(std::make_pair(dx, dy));
      }
    }

    return neightors;
  }

  bool isInArea(int x, int y, int row, int col) {
    return x >= 0 && x < row && y >= 0 && y < col;
  }

  struct state {
    int x, y;           // 二维平面中图的坐标
    int distfromstart;  // 从起点到达当前节点的最小距离

    state(int x, int y, int dis) : x(x), y(y), distfromstart(dis) {
    }
  };

  struct greator {
    bool operator()(const state &s1, const state &s2) {
      return s1.distfromstart > s2.distfromstart;
    }
  };

  const std::vector<std::vector<int>> dir = {{-1, 0},
                                             {1, 0},
                                             {0, -1},
                                             {0, 1}};  // 运动方向数组
};
```

3. 最大概率路径

```
给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。

指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。

如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。
```

分析：

1. 注意浮点数的比较形式；
2. 对`priority_queue`的默认为`less(a<b)`为大顶堆，`greator(a>b)`为小顶堆。

```cpp
#include <cmath>
#include <list>
#include <map>
#include <queue>
#include <vector>

// @lc code=start
const double eps = 1e-5;

class Solution {
public:
  double maxProbability(int                            n,
                        std::vector<std::vector<int>>& edges,
                        std::vector<double>&           succProb,
                        int                            start,
                        int                            end) {
    std::vector<double> res   = std::vector<double>(n, -1);
    auto                graph = createGraph(edges, succProb);
    std::priority_queue<state, std::vector<state>, less> hp; // 大根堆
    hp.push(state(start, 1));
    res[start] = 1;

    while (hp.size()) {
      state currstate = hp.top();
      hp.pop();
      int    currid   = currstate.id;
      double currdist = currstate.distfromstart;

      if (currid == end) {
        return currdist;
      }

      if (currdist + eps < res[currid]) {
        continue;
      }

      for (auto item : graph[currid]) {
        double dist = item.second * currdist;
        if (dist > eps + res[item.first]) {
          res[item.first] = dist;
          hp.push(state(item.first, dist));
        }
      }
    }

    return 0.0;
  }

private:
  std::map<int, std::list<std::pair<int, double>>> createGraph(
      std::vector<std::vector<int>>& edges,
      std::vector<double>&           succProb) {
    std::map<int, std::list<std::pair<int, double>>> graph;
    int                                              row = edges.size();

    for (int i = 0; i < row; i++) {
      graph[edges[i][0]].push_back(std::make_pair(edges[i][1], succProb[i]));
      graph[edges[i][1]].push_back(std::make_pair(edges[i][0], succProb[i]));
    }

    return graph;
  }

  struct state {
    int    id;
    double distfromstart;
    state(int id, double d) : id(id), distfromstart(d) {
    }
  };

  struct less {
    bool operator()(const state& s1, const state& s2) {
      return s1.distfromstart + eps < s2.distfromstart;
    }
  };
};
```

**`dijkstra`算法中求最大值用大根堆(`less(a<b)`),求最小值用小跟堆(`greator(a>b)`)**

### 二分图

### `kruskal`最小生成树
