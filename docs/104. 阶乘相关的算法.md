```
输入一个非负整数n，请你计算阶乘n!的结果末尾有几个 0。
```

分析：
结果的末尾的 0 从哪里来的？

1. 两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。

问题转化为：n!最多可以分解出多少个因子 2 和 5？
主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。
问题转化为：n!最多可以分解出多少个因子 5？
只需计算 n 中有多少个`5`的倍数，`5^n`的倍数，求他们之和即可。

```cpp
class Solution {
public:
  int trailingZeroes(int n) {
    int  res     = 0;
    long divisor = 5;
    while (divisor <= n) {
      res += n / divisor;
      divisor *= 5;
    }

    return res;
  }
};
```

```
输入一个非负整数K，请你计算有多少个n，满足n!的结果末尾恰好有K个 0。
```

搜索有多少个 n 满足 trailingZeroes(n) == K，其实就是在问，满足条件的 n 最小是多少，最大是多少，最大值和最小值一减，就可以算出来有多少个 n 满足条件了。

```cpp
class Solution {
public:
  long preimageSizeFZF(long k) {
    return right_bound(k) - left_bound(k) + 1;
  }

private:
  // 查找左边界
  long left_bound(long k) {
    long left = 0, right = LONG_MAX;

    while (left < right) {
      long mid = left + (right - left) / 2;
      long tmp = trailingZeroes(mid);
      if (k == tmp) {
        right = mid;
      } else if (tmp < k) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    return left;
  }

  // 查找右边界
  long right_bound(long k) {
    long left = 0, right = LONG_MAX;

    while (left < right) {
      long mid = left + (right - left) / 2;
      long tmp = trailingZeroes(mid);
      if (k == tmp) {
        left = mid + 1;
      } else if (tmp < k) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    return left - 1;
  }

  long trailingZeroes(long n) {
    // 计算n的阶乘中0的个数
    long res = 0;

    for (long d = n; d / 5 > 0; d = d / 5) {
      res += d / 5;
    }

    return res;
  }
};
```

### 阶乘中最低位`1`的位置

最低位`1`的位置，取决于`1~N`的数中，因子`2`有多少个。因为只要出现一个因子`2`，最低位的`1`就向左移动一位.
如果将`N!`中因子`2`的个数记为`Z`,则得到如下关系式：
$$Z=\frac{N}{2}+\frac{N}{4}+...+\frac{N}{2^i}, 2^i > N$$

```cpp
int rightOne(int num) {
  if(num < 1) {
    return -1;
  }

  int res = 0;
  while(num != 0){
    num >>= 1;
    res+=num;
  }

  return res;
}
```
