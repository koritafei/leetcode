讨论如下问题：
```
给你n个人的社交关系（你知道任意两个人之间是否认识），然后请你找出这些人中的「名人」。
所谓「名人」有两个条件：
1、所有其他人都认识「名人」。
2、「名人」不认识任何其他人。
```
分析：
如果将这`n`个人的社交关系构建一幅有向图，对于名人：
```
出度为0, 即没有指向其他节点的边；
入度为n-1, 即其他节点都指向该节点。
```
其数学化描述为：
给你输入一个`n * n`的矩阵(图的邻接矩阵)，`graph`表示图有`n`个节点，每个人代表图中的一个节点，编号从`0 到 n-1`.
其中`graph[i][j] == 1`代表了第`i`个人认识第`j`个人，`graph[i][j] == 0`表示第`i`个人不认识第`j`个人。

从上述描述可以看出，查找名人只需找到入度为`n-1`且出度为`0`的节点即可。
对`leetcode 277`题有如下解法：
1. 暴力搜索：
```cpp
int findCelebrity(int n) {
  for(int cond = 0; cond < n; cond++){
    int other;
    for(other = 0;other < n;other++){
      if(other == cond) {
        continue;
      }

      if(knows(cond,other) || !konws(other, cond)){
        break;
      }

    }

    if(other == n){
      return cond;
    }

  }

  return -1; // 不存在
}
```
优化解法：
```cpp
int findCelebrity(int n) {
  int cond = 0;
  for(int other = 1; other < n ;other++){
    if(!know(other, cond) || konw(cond, other)){
      // cond 非候选人，更新
      cond = other;
    } else {
      // do nothing
    }
  }

  // 判断是否正确
  for(int other = 0; other < n; other++){
    if(other == cond) {
      continue;
    }

    if(!know(other, cond) || know(cond, other)){
      return -1;
    }
  }

  return cond;
}
```

