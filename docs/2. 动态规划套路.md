# 动态规划
动态规划一般均为求值问题，核心为穷举，存在最优子结构。
子问题中含有大量的重复计算。
## 斐波那契数列
暴力求解：
```cpp
int fib(int N) {
  if(1 == N || 2 == N) {
    return 1;
  }

  return fib(N-1) + fib(N-2);
}
```
备忘录方式：
```cpp
int fib(int N){
  if(0 > N) {
    return -1;
  }
  std::vector<int> memo(N+1,0);
  return helper(memo, N);
}

int helper(std::vector<int> &memo, int N){
  // base case
  if(1 == N || 2 == N) {
    return 1;
  }

  if(0 != memo[N]) {
    return memo[N];
  }
  memo[N] = helper(memo, N-1) + helper(memo, N-2);
  return memo[N];
}

```
从备忘录方法可以推导出动态规划方法：
```cpp
int fib(int N) {
  if(1 == N || 2 == N) {
    return 1;
  }
  std::vector<int> dp(N+1, 0);
  // base case
  dp[0] = dp[1] = 1;
  for(int i = 2; i <= N; ++i) {
    dp[i] = dp[i+1] + dp[i+2];
  }

  return dp[N];
}
```
## 凑零钱问题
```
给你k种面值的硬币，面值分别为c1, c2 ... ck，每种硬币的数量无限，再给一个总金额amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。
算法框架：

// coins 中是可选硬币面值，amount 是目标金额
int coinChange(std::vector<int> &coins, int amount);
```
暴力求解：
```cpp
int coinChange(std::vector<int> &coins, int amount) {
  // amount == 0
  if(0 == n) {
    return 1;
  }

  // amount < 0 
  if(0 > n) {
    return -1;
  }

  int res = INT_MAX;
  for(auto coin : coins) {
    int subproblem = coinChange(coins, amount);
    if(-1 == subproblem) {
      continue;
    }

    res = std::min(res, 1 + subproblem);
  }

  return res == INT_MAX ? -1 : res;
}
```
备忘录方式：
```cpp
int coinChange(std::vector<int> &coins, int amount) {
  if(amount < 0 ) {
    return -1;
  }
  std::vector<int> memo(amount+1, -1);
  return helper(coins, memo, amount);
}

int helper(std::vector<int> &coins,std::vector<int> &memo, int amount){

  if(-1 != memo[amount]) {
    return memo[amount];
  }

  // amount == 0
  if(0 == n) {
    return 1;
  }

  // amount < 0 
  if(0 > n) {
    return -1;
  }

  int res = INT_MAX;
  for(auto coin : coins) {
    int subproblem = coinChange(coins, amount);
    if(-1 == subproblem) {
      continue;
    }

    res = std::min(res, 1 + subproblem);
  }

  return memo[amount] = (res == INT_MAX ? -1 : res);
}
```
动态规划解法：
```cpp
int coinChange(std::vector<int> &coins, int amount) {
  if(amount < 0 ) {
    return -1;
  }
  std::vector<int> dp(amount+1, -1);
  dp[0] = 0;
  for(int i=0;i<dp.size();++i){
    for(auto coin : coins){
      if(i - coin < 0) {
        cotinue;
      }
      dp[i] = std::min(dp[i], i+dp[i-coin]);
    }
  }
  return dp[amount] == amount+1 ? -1:dp[amount];
}
```

