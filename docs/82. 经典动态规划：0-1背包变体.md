```
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。（416）
```
分析：
1. 分成两个子集，和相等，那么数组的和一定能够被`2`整除；记`target = sum / 2`
2. 目标变为从一个数组中选中一组数使其值为`target`, 换个角度为：给定一组重量，一个背包可以放置`target`的重量，能否选择一组重量使得和为`target`,类似于`0-1`背包问题。
3. 和`0-1`背包的区别为：此处只能选择数据放入或不放入，无需计算价值，且最后重量一定等于`target`。


```cpp
class Solution {
public:
  bool canPartition(std::vector<int>& nums) {
    int sum = getSum(nums);
    if (0 != sum % 2) {
      return false;
    }

    int                            target = sum / 2;
    std::vector<std::vector<bool>> dp =
        std::vector<std::vector<bool>>(nums.size() + 1,
                                       std::vector<bool>(target + 1, false));
    // base case
    for (int i = 0; i <= nums.size(); i++) {
      dp[i][0] = true;
    }

    // dp 数组计算
    for (int i = 1; i <= nums.size(); i++) {
      for (int j = 1; j <= target; j++) {
        if (j - nums[i - 1] < 0) {  // 不能放下nums[i-1]
          dp[i][j] = dp[i - 1][j];
        } else {
          dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i - 1]];
        }
      }
    }

    return dp[nums.size()][target];
  }

private:
  int getSum(std::vector<int>& nums) {
    int sum = 0;
    for (auto item : nums) {
      sum += item;
    }

    return sum;
  }
};
```
