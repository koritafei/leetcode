```
幂运算a^b的计算结果与 1337 取模（mod，也就是余数）后的结果
```
取模计算可以有如下计算方法：
$$(a * b) \% k = (a\%k)*(b\%k)\%k $$

利用递归方式求解：
```cpp
class Solution {
public:
  int superPow(int a, std::vector<int>& b) {
    if (b.empty()) {
      return 1;
    }

    int last = b.back();
    b.pop_back();

    int part1 = mypow(a, last);
    int part2 = mypow(superPow(a, b), 10);

    return part1 * part2 % base;
  }

private:
  int mypow(int a, int k) {
    // 对因子取模
    a %= base;
    int res = 1;
    for (int i = 0; i < k; i++) {
      res *= a;
      res %= base;
    }

    return res;
  }

  int base = 1337;
};
```
### 优化
```cpp
class Solution {
public:
  int superPow(int a, std::vector<int>& b) {
    if (b.empty()) {
      return 1;
    }

    int last = b.back();
    b.pop_back();

    int part1 = mypow(a, last);
    int part2 = mypow(superPow(a, b), 10);

    return part1 * part2 % base;
  }

private:
  int mypow(int a, int k) {
    if (k == 0) {
      return 1;
    }

    if (k % 2 == 0) {
      int sub = mypow(a, k / 2);
      return sub * sub % base;
    } else {
      return a * mypow(a, k - 1) % base;
    }
  }

  int base = 1337;
};
```
当幂指数为偶数时，可以转换成$a^k =  (a^{k/2})^2$, 减少乘法运算。


