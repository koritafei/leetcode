## 红黑树
红黑树有以下性质：
1. 每个节点都是红色或黑色；
2. 根节点为黑色；
3. 每个叶子节点(`nullptr`)是黑色的；
4. 如果一个节点是红色那么他的两个孩子为黑色；
5. 对每个节点，从该节点到其所有后代的节点的简单路径上，均包含相同数量的黑色节点。

> * 红黑树中的叶子节点均指`nil`节点；
> * 性质5保证没有一条路径比其他路径长2倍，因此，红黑树是相对平衡的二叉树。

![RB_tree](./images/RB_tree.png)

### `RB_Tree`旋转定义
假设红黑树节点定义如下：
```cpp
enum RBColor { BLACK, RED };

template <class KeyType>
struct RBNode {
  KeyType          key;
  RBColor          color;
  RBNode<KeyType> *left;
  RBNode<KeyType> *right;
  RBNode<KeyType> *parent;

  RBNode(KeyType key, RBColor color, RBNode *p, RBNode *l, RBNode *r)
      : key(key), color(color), parent(p), left(l), right(r) {
  }
};

template <typename T>
class RBTree {
public:
  RBTree();
  ~RBTree();

  void       insert(T key);  // 插入key
  void       remove(T key);  // 删除key
  RBNode<T> *search(T key);  // 查找key
  void       print();

  void preOrder();   // 先序遍历
  void inOrder();    // 中序遍历
  void postOrder();  // 后序遍历

private:
  void leftRotate(RBNode<T> *&root, RBNode<T> *node);   // 左旋
  void rightRotate(RBNode<T> *&root, RBNode<T> *node);  // 右旋

  void insert(RBNode<T> *root, RBNode<T> *node);  // 插入节点
  void insertFixUp(RBNode<T> *root, RBNode<T> *node);
  void destory(RBNode<T> *node);

  void remove(RBNode<T> *&root, RBNode<T> *node);
  void removeFixUp(RBNode<T> *&root, RBNode<T> *node, RBNode<T> *parent);

  RBNode<T> *search(RBNode<T> *root, T key) const;
  void       print(RBNode<T> *root) const;
  void       preOrder(RBNode<T> *root) const;
  void       inOrder(RBNode<T> *root) const;
  void       postOrder(RBNode<T> *root) const;

  RBNode<T> *root;
};
```
* 以某个节点为轴，它的左子树顺时针旋转为左子树，作为新子树的根。成为顺时针旋转或右旋转。
![右旋转](./images/右旋转.png)
代码实现：
```cpp
// 右旋
template <typename T>
void RBTree<T>::rightRotate(RBNode<T> *&root, RBNode<T> *node) {
  // 获取轴节点的左子树根节点，记为左节点
  RBNode<T> *left = node->left;
  // 左节点的右子树链接到轴节点的左侧，成为轴节点的左子树
  node->left = left->right;

  // 如果左节点的左子树不空，设置其父节点为轴节点
  if (nullptr != left->right) {
    left->right->parent = node;
  }

  // 处理轴节点的父节点与父节点的左右子树
  left->parent = node->parent;

  if (nullptr == node->parent) {
    root = left;
  } else {
    // 轴节点为其父节点的左子树时
    if (node == node->parent->left) {
      // 左节点链接到其左子树上
      node->parent->left = left;
    } else {
      node->parent->right = left;
    }
  }

  // 将轴节点的作为左节点的右子树链接
  left->right  = node;
  node->parent = left;
}
```

* 以某个节点为轴，它的右支逆时针旋转，作为新字数的根，我们称之为左旋。
![左旋](./images/左旋.png)
```cpp
// 左旋
template <typename T>
void RBTree<T>::leftRotate(RBNode<T> *&root, RBNode<T> *node) {
  // 将当前右子树的左子树，改为轴节点的右子树
  RBNode<T> *right = node->right;

  node->right = right->left;

  // 如果左子树不为空，设置其父节点为轴节点
  if (nullptr != right->left) {
    right->left->parent = node;
  }

  // 右子树节点的父节点为轴节点的父节点
  right->parent = node->parent;

  if (nullptr == node->parent) {
    root = right;
  } else {
    // 轴节点为父节点的左节点时，需要将轴节点的父节点的左子树设置为右节点
    if (node == node->parent->left) {
      node->parent->left = right;
    } else {
      // 轴节点为父节点的右子树时，需要将右节点链接到轴的父节点的右子树
      node->parent->right = right;
    }
  }

  // 将轴节点变为到右子树左节点
  right->left  = node;
  node->parent = right;  // 轴节点的父节点改为右子树
}

```

### 红黑树的插入
1. 原理分析
红黑树将新节点`node`作为一个红色节点，插入到叶子节点上，将其孩子指针指向`nil`叶子节点，当新节点`node`的父节点为红色时,由于违反了性质`4`,因此需要进行调整，
**同一时刻红黑树只能违反一条性质。**

红黑树插入新节点的三种情况：
1. 新节点的叔父节点为红色。
![RBTree](./images/rbinsert1.png)
左图中插入的新节点`z(B)`是一个红色节点，其父节点`A`是红色的，违反了`性质4`，所以需要进行调整（由于节点A是红色的，根据性质4，因树本身是平衡的，所以节点C必然是黑色的）。
因为其叔节点`y(D)`是红色的，于是可以修改`节点A、节点D为黑色`，此时节点C的黑高就会发生变化， 从原来的1（忽略子树a、b、r、d、e的黑高）变成了2， 
因此还需要将节点C变成红色以保持其黑高不变。
此时，由于节点C由黑色变成了红色，如果节点C的父节点是红色，那么会违反性质4， 于是节点C变成了新的节点z， 从这里开始向上回溯调整树。
注意：
* 新插入的节点`z`是节点`A`的左子树与上述情况一致；
* 新插入节点`z`是节点`C`的左子树的节点，情况与此对称。

2. `z`的叔父节点是黑色，且`z`是一个右孩子
情况2不能像情况1那样通过修改z的父节点的颜色来维持性质4， 因为如果将z的父节点变成了黑色， 那么树的黑高就会发生变化， 必然会引起对性质5的违反。
以上面情况1的图为例， 假设此时节点y为黑色， 那么节点C的右子树高度为2（忽略子树d和e）， 左子树高也相同（因为树是平衡的）， 
如果简单的修改节点A为黑色， 那么节点C的左子树的黑高会比右子树大1， 此时即使将节点C修改为红色也于事无补。
此时可以通过旋转节点z的父节点使情况2变成情况3进行处理。

3. z的叔节点是黑色，且z是一个左孩子
![rbinsert2](./images/rbinsert2.png)

```cpp
// 插入算法
template <typename T>
void RBTree<T>::insert(T key) {
  RBNode<T> *node = new RBNode<T>(key, RED, nullptr, nullptr, nullptr);
  insertFixUp(root, node);
}

template <typename T>
void RBTree<T>::insert(RBNode<T> *&root, RBNode<T> *node) {
  RBNode<T> *cur  = root;
  RBNode<T> *leaf = nullptr;

  // 查找叶子节点
  while (nullptr != cur) {
    leaf = cur;
    // 二叉搜索树的值的性质适用
    if (node->key > cur->key) {
      cur = cur->right;
    } else {
      cur = cur->left;
    }
  }

  node->parent = leaf;

  // 插入节点
  if (nullptr != leaf) {
    if (node->key > leaf->key) {
      leaf->right = node;
    } else {
      leaf->left = node;
    }
  } else {
    root = node;
  }

  node->color = RED;
  insertFixUp(root, node);
}

// 调整RB Tree
template <typename T>
void RBTree<T>::insertFixUp(RBNode<T> *&root, RBNode<T> *node) {
  RBNode<T> *parent = node->parent;

  while (node != RBTree::root && parent->color == RED) {
    RBNode<T> *gparent = parent->parent;

    if (parent == gparent->left) {  // 父节点为祖父节点的左子树
      RBNode<T> *uncle = gparent->right;  // 插入节点的叔父节点

      if (nullptr != uncle && uncle->color == RED) {
        parent->color  = BLACK;  // 父节点和叔父节点设置为黑色
        uncle->color   = BLACK;
        gparent->color = RED;      // 祖父节点设置为红色
        node           = gparent;  // 向上递归
        parent         = node->parent;
      } else {
        // 如果插入节点为右节点
        if (node == parent->right) {
          // 以parent为轴，左旋
          leftRotate(root, parent);
          swap(node, parent);  // 交换当前节点和轴节点
        }

        // 以祖父节点为轴右旋
        rightRotate(root, gparent);
        gparent->color = BLACK;
        parent->color  = RED;
        break;
      }
    } else {
      RBNode<T> *uncle = gparent->left;

      if (nullptr != uncle && RED == uncle->color) {
        gparent->color = RED;
        parent->color  = BLACK;
        uncle->color   = BLACK;

        node    = parent;
        gparent = parent->parent;
      } else {
        if (node == parent->left) {
          rightRotate(root, parent);
          swap(node, parent);
        }

        leftRotate(root, gparent);
        parent->color  = BLACK;
        gparent->color = RED;
        break;
      }
    }
  }

  root->color = BLACK;
}
```
#### 红黑删除原理
红黑树只有黑色节点删除的时候需要调整，因为只有此时可能违反性质5或性质4.
1. 二叉搜索树删除
针对二叉搜索树删除有以下三种情况：
* 节点z没有孩子节点，只需简单将其删除，并修改父节点，用`nullptr`指向其汉子节点；
* 如果节点z只有一个孩子，那么将孩子节点提升到z的位置，并修改z的父节点，用z的孩子替换z。
* 如果节点z有两个孩子，寻找z的左子树的最左节点，替换z节点即可。

![RBTree旋转](./images/RBTree旋转.png)
删除后红黑树的调整：
设`x`为被替换节点，有：
* 在被删除节点的左子树为空时，`x`为被删除节点的右孩子；
* 在被删除节点的右子树为空时，`x`为被删除节点的左孩子；
* 替换节点`x`是空节点；
* 在被删除节点的左右子树均不为空时，`x`为后继节点中序遍历的右孩子。

a. x的兄弟节点w的颜色是红色的。
![RBTreeRemove1](./images/RBTreeRemove1.png)
b. x的兄弟节点w是黑色的，并且w的两个子节点都是黑色的。
![rbTreeRemove](./images/RBTreeRemove2.png)
c. x的兄弟节点w是黑色的，而且w的左孩子是红色的，w的右孩子是黑色的
![rbtreeremove](./images/RBTreeRemove3.png)
d. x的兄弟节点w是黑色的，并且w的右孩子是红色的
![rbtreeremove](./images/RBTreeRemove4.1.png)
![rbtreeremove](./images/RBTreeRemove4.2.png)
![rbtreeremove](./images/RBTreeRemove4.3.png)
![rbtreeremove](./images/RBTreeRemove4.4.png)

```cpp
// 红黑树删除
template <typename T>
void RBTree<T>::remove(T key) {
  RBNode<T> *deletenode = search(key);

  if (nullptr != deletenode) {
    remove(root, deletenode);
  }
}

template <typename T>
void RBTree<T>::remove(RBNode<T> *&root, RBNode<T> *node) {
  RBNode<T> *child, *parent;
  RBColor    color;

  // 被删除节点为非叶子结点
  if (nullptr != node->left && nullptr != node->right) {
    RBNode<T> *replace = node;

    // 查找后继节点，右子树的最左节点
    replace = node->right;
    while (replace->left) {
      replace = replace->left;
    }

    // 被删节点不为根节点的情况
    if (nullptr != node->parent) {
      if (node == node->parent->left) {
        node->parent->left = replace;
      } else {
        node->parent->right = replace;
      }
    } else {
      // 根节点的情况
      root = replace;
    }

    // child是后续节点的右节点，是需要调整的节点
    // replace是后继节点，不可能存在左节点
    //同理前驱节点不可能存在右节点
    child  = replace->right;
    parent = replace->parent;
    color  = replace->color;

    // 被删节点时取代节点的父节点的情况
    if (node == parent) {
      parent = replace;
    } else {
      // child节点存在的情况
      if (nullptr != child) {
        child->parent = parent;
      }

      parent->left        = child;
      replace->right      = node->right;
      node->right->parent = replace;
    }

    replace->parent    = node->parent;
    replace->color     = node->color;
    replace->parent    = node->parent;
    node->left->parent = replace;

    if (BLACK == color) {
      removeFixUp(root, replace, parent);
    }

    delete node;
    return;
  }

  // 被删除节点只有左节点的情况，找到被删除节点的子节点
  if (nullptr != node->left) {
    child = node->left;
  } else {
    child = node->right;
  }

  parent = node->parent;
  color  = node->color;

  if (child) {
    child->parent = parent;
  }

  // 被删除节点不为根节点
  if (nullptr != parent) {
    if (parent->left == node) {
      parent->left = child;
    } else {
      parent->right = child;
    }
  } else {
    RBTree::root = child;
  }

  if (BLACK == color) {
    removeFixUp(root, child, parent);
  }

  return;
}

template <typename T>
void RBTree<T>::removeFixUp(RBNode<T> *&root,
                            RBNode<T>  *node,
                            RBNode<T>  *parent) {
  RBNode<T> *othernode;
  while (!node || BLACK == node->color && RBTree::root != node) {
    if (node == parent->left) {
      othernode = parent->right;
      if (RED == othernode->color) {
        othernode->color = BLACK;
        parent->color    = RED;
        leftRotate(root, parent);
        othernode = parent->right;
      } else {
        if (!othernode->right || BLACK == othernode->right->color) {
          othernode->left->color = BLACK;
          othernode->color       = RED;
          rightRotate(root, othernode);
          othernode = parent->right;
        }

        othernode->color        = parent->color;
        parent->color           = BLACK;
        othernode->right->color = BLACK;
        leftRotate(root, parent);
        node = root;
        break;
      }
    } else {
      othernode = parent->left;
      if (RED == othernode->color) {
        othernode->color = BLACK;
        parent->color    = RED;
        rightRotate(root, parent);
        othernode = parent->left;
      }

      if ((!othernode->left || BLACK == othernode->left->color) &&
          (!othernode->right || BLACK == othernode->right->color)) {
        othernode->color = RED;
        node             = parent;
        parent           = node->parent;
      } else {
        if (!othernode->left || othernode->left->color == BLACK) {
          othernode->right->color = BLACK;
          othernode->color        = RED;
          leftRotate(root, othernode);
          othernode = parent->left;
        }

        othernode->color       = parent->color;
        parent->color          = BLACK;
        othernode->left->color = BLACK;
        rightRotate(root, parent);
        node = root;
        break;
      }
    }
  }

  if (node) {
    node->color = BLACK;
  }
}
```

### B树与B+树

 B树就是常说的“B 减树（B- 树）”，又名平衡多路（即不止两个子树）查找树，它和平衡二叉树的不同有这么几点：
    
        平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树
        平衡二叉树每个节点只有一个数据和两个指向孩子的指针，而 B 树每个中间节点有 k-1 个关键字（可以理解为数据）和 k 个子树（ **k 介于阶数 M 和 M/2 之间，M/2 向上取整）
        B 树的所有叶子节点都在同一层，并且叶子节点只有关键字，指向孩子的指针为 null

一棵 B+ 树需要满足以下条件：
    
        节点的子树数和关键字数相同（B 树是关键字数比子树数少一）
        节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据
        叶子节点包含了全部数据，同时符合左小右大的顺序

B+ 树的三个特点：

    关键字数和子树相同
    非叶子节点仅用作索引，它的关键字和子节点有重复元素
    叶子节点用指针连在一起

B+ 树的三个优点：

    层级更低，IO 次数更少
    每次都需要查询到叶子节点，查询性能稳定
    叶子节点形成有序链表，范围查询方便






