## 红黑树
红黑树有以下性质：
1. 每个节点都是红色或黑色；
2. 根节点为黑色；
3. 每个叶子节点(`nullptr`)是黑色的；
4. 如果一个节点是红色那么他的两个孩子为黑色；
5. 对每个节点，从该节点到其所有后代的节点的简单路径上，均包含相同数量的黑色节点。

> * 红黑树中的叶子节点均指`nil`节点；
> * 性质5保证没有一条路径比其他路径长2倍，因此，红黑树是相对平衡的二叉树。

![RB_tree](./images/RB_tree.png)

### `RB_Tree`旋转定义
假设红黑树节点定义如下：
```cpp
enum RBColor { BLACK, RED };

template <class KeyType>
struct RBNode {
  KeyType          key;
  RBColor          color;
  RBNode<KeyType> *left;
  RBNode<KeyType> *right;
  RBNode<KeyType> *parent;

  RBNode(KeyType key, RBColor color, RBNode *p, RBNode *l, RBNode *r)
      : key(key), color(color), parent(p), left(l), right(r) {
  }
};

template <typename T>
class RBTree {
public:
  RBTree();
  ~RBTree();

  void       insert(T key);  // 插入key
  void       remove(T key);  // 删除key
  RBNode<T> *search(T key);  // 查找key
  void       print();

  void preOrder();   // 先序遍历
  void inOrder();    // 中序遍历
  void postOrder();  // 后序遍历

private:
  void leftRotate(RBNode<T> *&root, RBNode<T> *node);   // 左旋
  void rightRotate(RBNode<T> *&root, RBNode<T> *node);  // 右旋

  void insert(RBNode<T> *root, RBNode<T> *node);  // 插入节点
  void insertFixUp(RBNode<T> *root, RBNode<T> *node);
  void destory(RBNode<T> *node);

  void remove(RBNode<T> *&root, RBNode<T> *node);
  void removeFixUp(RBNode<T> *&root, RBNode<T> *node, RBNode<T> *parent);

  RBNode<T> *search(RBNode<T> *root, T key) const;
  void       print(RBNode<T> *root) const;
  void       preOrder(RBNode<T> *root) const;
  void       inOrder(RBNode<T> *root) const;
  void       postOrder(RBNode<T> *root) const;

  RBNode<T> *root;
};
```
* 以某个节点为轴，它的左子树顺时针旋转为左子树，作为新子树的根。成为顺时针旋转或右旋转。
![右旋转](./images/右旋转.png)
代码实现：
```cpp
// 右旋
template <typename T>
void RBTree<T>::rightRotate(RBNode<T> *&root, RBNode<T> *node) {
  // 获取轴节点的左子树根节点，记为左节点
  RBNode<T> *left = node->left;
  // 左节点的右子树链接到轴节点的左侧，成为轴节点的左子树
  node->left = left->right;

  // 如果左节点的左子树不空，设置其父节点为轴节点
  if (nullptr != left->right) {
    left->right->parent = node;
  }

  // 处理轴节点的父节点与父节点的左右子树
  left->parent = node->parent;

  if (nullptr == node->parent) {
    root = left;
  } else {
    // 轴节点为其父节点的左子树时
    if (node == node->parent->left) {
      // 左节点链接到其左子树上
      node->parent->left = left;
    } else {
      node->parent->right = left;
    }
  }

  // 将轴节点的作为左节点的右子树链接
  left->right  = node;
  node->parent = left;
}
```

* 以某个节点为轴，它的右支逆时针旋转，作为新字数的根，我们称之为左旋。
![左旋](./images/左旋.png)
```cpp
// 左旋
template <typename T>
void RBTree<T>::leftRotate(RBNode<T> *&root, RBNode<T> *node) {
  // 将当前右子树的左子树，改为轴节点的右子树
  RBNode<T> *right = node->right;

  node->right = right->left;

  // 如果左子树不为空，设置其父节点为轴节点
  if (nullptr != right->left) {
    right->left->parent = node;
  }

  // 右子树节点的父节点为轴节点的父节点
  right->parent = node->parent;

  if (nullptr == node->parent) {
    root = right;
  } else {
    // 轴节点为父节点的左节点时，需要将轴节点的父节点的左子树设置为右节点
    if (node == node->parent->left) {
      node->parent->left = right;
    } else {
      // 轴节点为父节点的右子树时，需要将右节点链接到轴的父节点的右子树
      node->parent->right = right;
    }
  }

  // 将轴节点变为到右子树左节点
  right->left  = node;
  node->parent = right;  // 轴节点的父节点改为右子树
}

```

### 红黑树的插入
1. 原理分析
红黑树将新节点`node`作为一个红色节点，插入到叶子节点上，将其孩子指针指向`nil`叶子节点，当新节点`node`的父节点为红色时,由于违反了性质`4`,因此需要进行调整，
**同一时刻红黑树只能违反一条性质。**

红黑树插入新节点的三种情况：
1. 新节点的叔父节点为红色。
![RBTree](./images/rbinsert1.png)
左图中插入的新节点`z(B)`是一个红色节点，其父节点`A`是红色的，违反了`性质4`，所以需要进行调整（由于节点A是红色的，根据性质4，因树本身是平衡的，所以节点C必然是黑色的）。
因为其叔节点`y(D)`是红色的，于是可以修改`节点A、节点D为黑色`，此时节点C的黑高就会发生变化， 从原来的1（忽略子树a、b、r、d、e的黑高）变成了2， 
因此还需要将节点C变成红色以保持其黑高不变。
此时，由于节点C由黑色变成了红色，如果节点C的父节点是红色，那么会违反性质4， 于是节点C变成了新的节点z， 从这里开始向上回溯调整树。
注意：
* 新插入的节点`z`是节点`A`的左子树与上述情况一致；
* 新插入节点`z`是节点`C`的左子树的节点，情况与此对称。

2. `z`的叔父节点是黑色，且`z`是一个右孩子
情况2不能像情况1那样通过修改z的父节点的颜色来维持性质4， 因为如果将z的父节点变成了黑色， 那么树的黑高就会发生变化， 必然会引起对性质5的违反。
以上面情况1的图为例， 假设此时节点y为黑色， 那么节点C的右子树高度为2（忽略子树d和e）， 左子树高也相同（因为树是平衡的）， 
如果简单的修改节点A为黑色， 那么节点C的左子树的黑高会比右子树大1， 此时即使将节点C修改为红色也于事无补。
此时可以通过旋转节点z的父节点使情况2变成情况3进行处理。

3. z的叔节点是黑色，且z是一个左孩子
![rbinsert2](./images/rbinsert2.png)

```cpp
// 插入算法
template <typename T>
void RBTree<T>::insert(T key) {
  RBNode<T> *node = new RBNode<T>(key, RED, nullptr, nullptr, nullptr);
  insertFixUp(root, node);
}

template <typename T>
void RBTree<T>::insert(RBNode<T> *&root, RBNode<T> *node) {
  RBNode<T> *cur  = root;
  RBNode<T> *leaf = nullptr;

  // 查找叶子节点
  while (nullptr != cur) {
    leaf = cur;
    // 二叉搜索树的值的性质适用
    if (node->key > cur->key) {
      cur = cur->right;
    } else {
      cur = cur->left;
    }
  }

  node->parent = leaf;

  // 插入节点
  if (nullptr != leaf) {
    if (node->key > leaf->key) {
      leaf->right = node;
    } else {
      leaf->left = node;
    }
  } else {
    root = node;
  }

  node->color = RED;
  insertFixUp(root, node);
}

// 调整RB Tree
template <typename T>
void RBTree<T>::insertFixUp(RBNode<T> *&root, RBNode<T> *node) {
  RBNode<T> *parent = node->parent;

  while (node != RBTree::root && parent->color == RED) {
    RBNode<T> *gparent = parent->parent;

    if (parent == gparent->left) {  // 父节点为祖父节点的左子树
      RBNode<T> *uncle = gparent->right;  // 插入节点的叔父节点

      if (nullptr != uncle && uncle->color == RED) {
        parent->color  = BLACK;  // 父节点和叔父节点设置为黑色
        uncle->color   = BLACK;
        gparent->color = RED;      // 祖父节点设置为红色
        node           = gparent;  // 向上递归
        parent         = node->parent;
      } else {
        // 如果插入节点为右节点
        if (node == parent->right) {
          // 以parent为轴，左旋
          leftRotate(root, parent);
          swap(node, parent);  // 交换当前节点和轴节点
        }

        // 以祖父节点为轴右旋
        rightRotate(root, gparent);
        gparent->color = BLACK;
        parent->color  = RED;
        break;
      }
    } else {
      RBNode<T> *uncle = gparent->left;

      if (nullptr != uncle && RED == uncle->color) {
        gparent->color = RED;
        parent->color  = BLACK;
        uncle->color   = BLACK;

        node    = parent;
        gparent = parent->parent;
      } else {
        if (node == parent->left) {
          rightRotate(root, parent);
          swap(node, parent);
        }

        leftRotate(root, gparent);
        parent->color  = BLACK;
        gparent->color = RED;
        break;
      }
    }
  }

  root->color = BLACK;
}
```
#### 红黑删除原理
红黑树只有黑色节点删除的时候需要调整，因为只有此时可能违反性质5或性质4.
1. 二叉搜索树删除
针对二叉搜索树删除有以下三种情况：
* 节点z没有孩子节点，只需简单将其删除，并修改父节点，用`nullptr`指向其汉子节点；
* 如果节点z只有一个孩子，那么将孩子节点提升到z的位置，并修改z的父节点，用z的孩子替换z。
* 如果节点z有两个孩子，寻找z的左子树的最左节点，替换z节点即可。

![RBTree旋转](./images/RBTree旋转.png)







